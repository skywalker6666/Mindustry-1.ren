'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var immutable = require('immutable');
var debug = _interopDefault(require('debug'));
var isPlainObject = _interopDefault(require('is-plain-object'));
var memoizeOne = _interopDefault(require('memoize-one'));
var warning = _interopDefault(require('tiny-warning'));

const TopicDirection = {
    LEFT: 'L',
    RIGHT: 'R',
    BOTTOM: 'B',
    MAIN: 'M' // root
};
(function (DiagramLayoutType) {
    DiagramLayoutType[DiagramLayoutType["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
    DiagramLayoutType[DiagramLayoutType["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
    DiagramLayoutType[DiagramLayoutType["LEFT_AND_RIGHT"] = 2] = "LEFT_AND_RIGHT";
    DiagramLayoutType[DiagramLayoutType["TOP_TO_BOTTOM"] = 3] = "TOP_TO_BOTTOM";
})(exports.DiagramLayoutType || (exports.DiagramLayoutType = {}));
const TopicVisualLevel = {
    ROOT: 0,
    PRIMARY: 1,
    NORMAL: 2
};
const BlockType = {
    CONTENT: 'CONTENT',
    DESC: 'DESC'
};
const FocusMode = {
    NORMAL: 'NORMAL',
    EDITING_CONTENT: 'EDITING_CONTENT',
    EDITING_DESC: 'EDITING_DESC',
    SHOW_POPUP: 'SHOW_POPUP',
    DRAGGING: 'DRAGGING'
};
const TopicRelationship = {
    ANCESTOR: 'ANCESTOR',
    DESCENDANT: 'DESCENDANT',
    SIBLING: 'SIBLING',
    NONE: 'NONE'
};
const OpType = {
    TOGGLE_COLLAPSE: 'TOGGLE_COLLAPSE',
    COLLAPSE_ALL: 'COLLAPSE_ALL',
    EXPAND_ALL: 'EXPAND_ALL',
    EXPAND_TO: 'EXPAND_TO',
    ADD_CHILD: 'ADD_CHILD',
    ADD_SIBLING: 'ADD_SIBLING',
    DELETE_TOPIC: 'DELETE_TOPIC',
    FOCUS_TOPIC: 'FOCUS_TOPIC',
    SET_FOCUS_MODE: 'SET_FOCUS_MODE',
    SET_STYLE: 'SET_STYLE',
    CLEAR_ALL_CUSTOM_STYLE: 'CLEAR_ALL_CUSTOM_STYLE',
    SET_THEME: 'SET_THEME',
    SET_TOPIC_BLOCK: 'SET_TOPIC_BLOCK',
    DELETE_TOPIC_BLOCK: 'DELETE_TOPIC_BLOCK',
    // SET_TOPIC_CONTENT: 'SET_TOPIC_CONTENT',
    // SET_TOPIC_DESC: 'SET_TOPIC_DESC',
    START_EDITING_CONTENT: 'START_EDITING_CONTENT',
    START_EDITING_DESC: 'START_EDITING_DESC',
    DRAG_AND_DROP: 'DRAG_AND_DROP',
    SET_EDITOR_ROOT: 'SET_EDITOR_ROOT',
    SET_LAYOUT_DIR: 'SET_LAYOUT_DIR'
};

const defaultBlockRecord = {
    type: null,
    key: null,
    data: null
};
class Block extends immutable.Record(defaultBlockRecord) {
    get data() {
        return this.get('data');
    }
    get type() {
        return this.get('type');
    }
    static create(obj) {
        return new Block(obj);
    }
    static createList(obj) {
        if (immutable.List.isList(obj) || Array.isArray(obj)) {
            // @ts-ignore
            return immutable.List(obj.map(Block.create));
        }
        throw new Error(`Block.createList only accepts Array or List, but you passed it: ${obj}`);
    }
}

function isThemeType(obj) {
    return (obj.name != null && obj.background != null && obj.highlightColor != null);
}

const defaultTheme = {
    name: 'default',
    randomColor: true,
    background: 'rgb(57,60,65)',
    highlightColor: '#50C9CE',
    marginH: 60,
    marginV: 20,
    contentStyle: {
        lineHeight: '1.5'
    },
    linkStyle: {
        lineRadius: 5,
        lineType: 'curve',
        lineWidth: '3px'
    },
    rootTopic: {
        contentStyle: {
            fontSize: '34px',
            borderRadius: '35px',
            padding: '16px 18px 16px 18px'
        },
        subLinkStyle: {
            lineType: 'curve',
            lineWidth: '3px',
            lineColor: 'rgb(113, 203, 45)'
        }
    },
    primaryTopic: {
        contentStyle: {
            borderWidth: '1px',
            borderStyle: 'solid',
            borderRadius: '20px',
            fontSize: '17px',
            padding: '10px 15px 10px 15px'
        },
        subLinkStyle: {
            lineType: 'curve',
            lineWidth: '3px',
            lineColor: 'rgb(113, 203, 45)'
        }
    },
    normalTopic: {
        contentStyle: {
            border: '1px solid #e8eaec',
            borderRadius: '20px',
            fontSize: '17px',
            padding: '4px 10px'
        },
        subLinkStyle: {
            lineType: 'curve',
            lineWidth: '3px',
            lineColor: 'white'
        }
    }
};

const defaultConfigRecord = {
    readOnly: false,
    allowUndo: true,
    layoutDir: exports.DiagramLayoutType.LEFT_AND_RIGHT,
    theme: defaultTheme
};
class Config extends immutable.Record(defaultConfigRecord) {
    get layoutDir() {
        return this.get('layoutDir');
    }
    get readOnly() {
        return this.get('readOnly');
    }
    get allowUndo() {
        return this.get('allowUndo');
    }
    get theme() {
        return this.get('theme');
    }
    static fromJSON(obj) {
        return new Config(obj);
    }
}

function createKey() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

const defaultTopicRecord = {
    key: null,
    parentKey: null,
    collapse: false,
    subKeys: null,
    blocks: null,
    relations: null,
    style: null
};
class Topic extends immutable.Record(defaultTopicRecord) {
    get key() {
        return this.get('key');
    }
    get parentKey() {
        return this.get('parentKey');
    }
    get collapse() {
        return this.get('collapse');
    }
    get subKeys() {
        return this.get('subKeys');
    }
    get blocks() {
        return this.get('blocks');
    }
    get relations() {
        return this.get('relations');
    }
    get style() {
        return this.get('style');
    }
    getBlock(type) {
        const index = this.blocks.findIndex(b => b.type === type);
        if (index === -1)
            return { index, block: null };
        return { index, block: this.blocks.get(index) };
    }
    static fromJSON(obj) {
        const { key, parentKey = null, blocks, subKeys = [], collapse = false } = obj;
        return new Topic({
            key,
            parentKey,
            collapse,
            subKeys: immutable.List(subKeys),
            blocks: Block.createList(blocks)
        });
    }
    static create({ key, parentKey = null, content = '', subKeys = [], collapse = false }) {
        const block = Block.create({
            type: BlockType.CONTENT,
            data: content,
            key: null
        });
        const blocks = immutable.List([block]);
        return new Topic({
            key,
            parentKey,
            blocks,
            subKeys: immutable.List(subKeys),
            collapse
        });
    }
}

function getAllSubTopicKeys(model, topicKey) {
    const item = model.getTopic(topicKey);
    let res = [];
    if (item.subKeys.size > 0) {
        const subKeys = item.subKeys.toArray();
        res.push(...subKeys);
        res = subKeys.reduce((acc, key) => {
            acc.push(...getAllSubTopicKeys(model, key));
            return acc;
        }, res);
    }
    return res;
}
function getKeyPath(model, topicKey, reverse = false) {
    const res = [topicKey];
    let item = model.getTopic(topicKey);
    while (item.parentKey) {
        reverse ? res.push(item.parentKey) : res.unshift(item.parentKey);
        item = model.getParentTopic(item.key);
    }
    return res;
}
function getRelationship(model, srcKey, dstKey) {
    const srcTopic = model.getTopic(srcKey);
    const dstTopic = model.getTopic(dstKey);
    if (srcTopic && dstTopic) {
        if (srcTopic.parentKey == dstTopic.parentKey)
            return TopicRelationship.SIBLING;
        let pTopic = srcTopic;
        while (pTopic.parentKey) {
            if (pTopic.parentKey === dstTopic.key)
                return TopicRelationship.DESCENDANT;
            pTopic = model.getParentTopic(pTopic.key);
        }
        pTopic = dstTopic;
        while (pTopic.parentKey) {
            if (pTopic.parentKey === srcTopic.key)
                return TopicRelationship.ANCESTOR;
            pTopic = model.getParentTopic(pTopic.key);
        }
    }
    return TopicRelationship.NONE;
}

const log = debug('modifier');
function toggleCollapse({ model, topicKey }) {
    let topic = model.getTopic(topicKey);
    if (topic && topic.subKeys.size !== 0) {
        topic = topic.merge({
            collapse: !topic.collapse
        });
        model = model.updateIn(['topics', topic.key, 'collapse'], collapse => !collapse);
    }
    model = focusTopic({ model, topicKey, focusMode: FocusMode.NORMAL });
    return model;
}
function collapseAll({ model }) {
    const topicKeys = getAllSubTopicKeys(model, model.editorRootTopicKey);
    log(model);
    model = model.withMutations(m => {
        topicKeys.forEach(topicKey => {
            m.setIn(['topics', topicKey, 'collapse'], true);
        });
    });
    model = focusTopic({
        model,
        topicKey: model.editorRootTopicKey,
        focusMode: FocusMode.NORMAL
    });
    return model;
}
function expandAll({ model }) {
    const topicKeys = getAllSubTopicKeys(model, model.editorRootTopicKey);
    log(model);
    model = model.withMutations(m => {
        topicKeys.forEach(topicKey => {
            m.setIn(['topics', topicKey, 'collapse'], false);
        });
    });
    log(model);
    return model;
}
function expandTo({ model, topicKey }) {
    const keys = getKeyPath(model, topicKey).filter(t => t !== topicKey);
    model = model.withMutations(m => {
        keys.forEach(topicKey => {
            m.setIn(['topics', topicKey, 'collapse'], false);
        });
    });
    // 要让这个节点在视口中可见
    if (getRelationship(model, topicKey, model.editorRootTopicKey) !==
        TopicRelationship.DESCENDANT) {
        model = model.set('editorRootTopicKey', model.rootTopicKey);
    }
    return model;
}
function focusTopic({ model, topicKey, focusMode }) {
    log('focus topic');
    if (topicKey !== model.focusKey)
        model = model.set('focusKey', topicKey);
    if (focusMode !== model.focusMode)
        model = model.set('focusMode', focusMode);
    return model;
}
function setFocusMode({ model, focusMode }) {
    log('setFocusMode');
    if (focusMode !== model.focusMode)
        model = model.set('focusMode', focusMode);
    return model;
}
function addChild({ model, topicKey }) {
    log('addChild:', topicKey);
    let topic = model.getTopic(topicKey);
    if (topic) {
        const child = Topic.create({ key: createKey(), parentKey: topic.key });
        topic = topic
            .set('collapse', false)
            .update('subKeys', subKeys => subKeys.push(child.key));
        model = model.update('topics', topics => topics.set(topicKey, topic).set(child.key, child));
        return focusTopic({
            model,
            topicKey: child.key,
            focusMode: FocusMode.EDITING_CONTENT
        });
    }
    return model;
}
function addSibling({ model, topicKey }) {
    if (topicKey === model.rootTopicKey)
        return model;
    const topic = model.getTopic(topicKey);
    if (topic) {
        const pItem = model.getTopic(topic.parentKey);
        const idx = pItem.subKeys.indexOf(topicKey);
        const sibling = Topic.create({ key: createKey(), parentKey: pItem.key });
        model = model
            .update('topics', topics => topics.set(sibling.key, sibling))
            .updateIn(['topics', pItem.key, 'subKeys'], subKeys => subKeys.insert(idx + 1, sibling.key));
        return focusTopic({
            model,
            topicKey: sibling.key,
            focusMode: FocusMode.EDITING_CONTENT
        });
    }
    return model;
}
function deleteTopic({ model, topicKey }) {
    if (topicKey === model.editorRootTopicKey)
        return model;
    const item = model.getTopic(topicKey);
    if (item) {
        model = model.withMutations(m => {
            m.update('topics', topics => {
                topics = topics.delete(topicKey);
                const deleteKeys = getAllSubTopicKeys(model, topicKey);
                topics = topics.withMutations(t => {
                    deleteKeys.forEach(dKey => {
                        t.delete(dKey);
                    });
                });
                return topics;
            });
            m.updateIn(['topics', item.parentKey, 'subKeys'], subKeys => subKeys.delete(subKeys.indexOf(topicKey)));
            if (m.focusKey === topicKey)
                m.set('focusKey', null).set('focusMode', null);
        });
    }
    return model;
}
/**
 * setBlockData of one topic
 * @param model
 * @param topicKey
 * @param blockType
 * @param focusMode
 * @param data
 */
function setBlockData({ model, topicKey, blockType, focusMode, data }) {
    const topic = model.getTopic(topicKey);
    if (topic) {
        const { index, block } = topic.getBlock(blockType);
        if (index === -1) {
            model = model.updateIn(['topics', topicKey, 'blocks'], blocks => blocks.push(Block.create({
                type: blockType,
                data: data
            })));
        }
        else {
            if (block.data !== data) {
                model = model.updateIn(['topics', topicKey, 'blocks', index, 'data'], dt => data);
            }
        }
        if (focusMode) {
            model = focusTopic({
                model,
                topicKey,
                focusMode
            });
        }
    }
    return model;
}
function deleteBlock({ model, topicKey, blockType }) {
    const topic = model.getTopic(topicKey);
    if (topic) {
        const { index } = topic.getBlock(blockType);
        if (index !== -1) {
            model = model.updateIn(['topics', topicKey, 'blocks'], blocks => blocks.delete(index));
        }
        model = focusTopic({
            model,
            topicKey: null,
            focusMode: null
        });
    }
    return model;
}
function setStyle({ model, topicKey, style }) {
    const topic = model.getTopic(topicKey);
    if (topic) {
        if (style !== topic.style) {
            model = model.updateIn(['topics', topicKey, 'style'], s => style);
        }
    }
    return model;
}
function clearAllCustomStyle({ model }) {
    model = model.withMutations(model => {
        model.topics.keySeq().forEach(key => {
            model.setIn(['topics', key, 'style'], null);
        });
    });
    return model;
}
function setTheme({ model, theme }) {
    model = model.setIn(['config', 'theme'], theme);
    return model;
}
function setLayoutDir({ model, layoutDir }) {
    if (model.config.layoutDir === layoutDir)
        return model;
    model = model.setIn(['config', 'layoutDir'], layoutDir);
    return model;
}
function setEditorRootTopicKey({ model, topicKey }) {
    if (model.editorRootTopicKey !== topicKey)
        model = model.set('editorRootTopicKey', topicKey);
    if (model.getTopic(topicKey).collapse)
        model = model.setIn(['topics', topicKey, 'collapse'], false);
    return model;
}
function setZoomFactor({ model, zoomFactor }) {
    if (model.zoomFactor !== zoomFactor)
        model = model.set('zoomFactor', zoomFactor);
    return model;
}
var modifiers = {
    addChild,
    addSibling,
    toggleCollapse,
    collapseAll,
    expandAll,
    expandTo,
    focusTopic,
    setFocusMode,
    deleteTopic,
    setBlockData,
    deleteBlock,
    setStyle,
    clearAllCustomStyle,
    setTheme,
    setLayoutDir,
    setEditorRootTopicKey,
    setZoomFactor
};

const defaultModelRecord = {
    topics: immutable.Map(),
    extData: immutable.Map(),
    config: new Config(),
    rootTopicKey: null,
    editorRootTopicKey: null,
    focusKey: null,
    focusMode: null,
    formatVersion: null,
    zoomFactor: 1
};
class Model extends immutable.Record(defaultModelRecord) {
    static isModel(obj) {
        return obj instanceof Model;
    }
    static create(attrs = null) {
        if (attrs == null)
            return Model.createEmpty();
        let res;
        if (Model.isModel(attrs)) {
            res = attrs;
        }
        if (isPlainObject(attrs)) {
            res = Model.fromJSON(attrs);
        }
        if (res) {
            if (res.focusKey == null) {
                res = res.set('focusKey', res.rootTopicKey);
            }
            if (res.focusMode == null) {
                res = res.set('focusMode', FocusMode.NORMAL);
            }
            return res;
        }
        throw new Error(`\`Value.create\` only accepts objects or values, but you passed it: ${attrs}`);
    }
    static createEmpty() {
        const model = new Model();
        const rootTopic = Topic.create({ key: createKey(), content: 'RootTopic' });
        return model
            .update('topics', topics => topics.set(rootTopic.key, rootTopic))
            .set('rootTopicKey', rootTopic.key)
            .set('editorRootTopicKey', rootTopic.key)
            .set('focusKey', rootTopic.key)
            .set('focusMode', FocusMode.NORMAL);
    }
    static fromJSON(object) {
        let model = new Model();
        const { topics = [], config = {}, rootTopicKey } = object;
        let { editorRootTopicKey } = object;
        if (editorRootTopicKey === undefined)
            editorRootTopicKey = rootTopicKey;
        model = model.merge({
            rootTopicKey,
            editorRootTopicKey
        });
        model = model.withMutations(model => {
            topics.forEach(topic => {
                model.update('topics', topics => topics.set(topic.key, Topic.fromJSON(topic)));
            });
            model.set('config', Config.fromJSON(config));
        });
        return model;
    }
    toJS() {
        const obj = {
            rootTopicKey: this.rootTopicKey,
            topics: Object.values(this.topics.toJS()),
            config: this.config,
            extData: this.extData,
            zoomFactor: this.zoomFactor
        };
        return obj;
    }
    get extData() {
        return this.get('extData');
    }
    get topics() {
        return this.get('topics');
    }
    get config() {
        return this.get('config');
    }
    get formatVersion() {
        return this.get('formatVersion');
    }
    get rootTopicKey() {
        return this.get('rootTopicKey');
    }
    get editorRootTopicKey() {
        return this.get('editorRootTopicKey');
    }
    get focusKey() {
        return this.get('focusKey');
    }
    get focusMode() {
        return this.get('focusMode');
    }
    get editingContentKey() {
        return this.focusMode === FocusMode.EDITING_CONTENT ? this.focusKey : null;
    }
    get editingDescKey() {
        return this.focusMode === FocusMode.EDITING_DESC ? this.focusKey : null;
    }
    getTopic(key) {
        return this.topics.get(key);
    }
    getExtDataItem(key, c) {
        return this.extData.get(key) || new c();
    }
    getParentTopic(key) {
        const topic = this.getTopic(key);
        return topic.parentKey ? this.getTopic(topic.parentKey) : null;
    }
    getTopicVisualLevel(key) {
        let topic = this.getTopic(key);
        let level = 0;
        while (topic && topic.key !== this.editorRootTopicKey) {
            level++;
            topic = this.getParentTopic(topic.key);
        }
        return level;
    }
    get rootTopic() {
        return this.getTopic(this.rootTopicKey);
    }
    get zoomFactor() {
        return this.get('zoomFactor');
    }
}

function CorePlugin(options = {}) {
    const { plugins = [] } = options;
    return [...plugins];
}

const log$1 = debug('core:controller');
function registerPlugin(controller, plugin) {
    if (Array.isArray(plugin)) {
        plugin.forEach(p => registerPlugin(controller, p));
        return;
    }
    if (plugin == null) {
        return;
    }
    for (const key in plugin) {
        const fn = plugin[key];
        controller.middleware[key] = controller.middleware[key] || [];
        controller.middleware[key].push(fn);
    }
}
// modified from koa-compose
function compose(middleware) {
    if (!Array.isArray(middleware))
        throw new TypeError('Middleware stack must be an array!');
    for (const fn of middleware) {
        if (typeof fn !== 'function')
            throw new TypeError('Middleware must be composed of functions!');
    }
    return function (context, next) {
        // last called middleware #
        let index = -1;
        return dispatch(0);
        function dispatch(i) {
            if (i <= index)
                throw new Error('next() called multiple times');
            index = i;
            let fn = middleware[i];
            if (i === middleware.length)
                fn = next;
            if (!fn)
                return null;
            try {
                return fn(context, dispatch.bind(null, i + 1));
            }
            catch (err) {
                throw err;
            }
        }
    };
}
class Controller {
    constructor(options = {}) {
        const { plugins = [], onChange, readOnly } = options;
        this.readOnly = readOnly;
        this.onChange = onChange;
        this.middleware = new Map();
        const corePlugin = CorePlugin({ plugins });
        registerPlugin(this, corePlugin);
    }
    run(key, ...args) {
        const { middleware } = this;
        const fns = middleware[key] || [];
        warning(fns.length !== 0, `the middleware function ${key} is not found!`);
        const composedFn = memoizeOne(compose)(fns);
        // @ts-ignore
        return composedFn(...args);
    }
    getValue(propKey, arg) {
        return this.run('getValue', { ...arg, propKey });
    }
    change(model, callback) {
        this.onChange(model, callback);
        this.currentModel = model;
    }
}

exports.Block = Block;
exports.BlockType = BlockType;
exports.Config = Config;
exports.Controller = Controller;
exports.FocusMode = FocusMode;
exports.Model = Model;
exports.ModelModifier = modifiers;
exports.OpType = OpType;
exports.Topic = Topic;
exports.TopicDirection = TopicDirection;
exports.TopicRelationship = TopicRelationship;
exports.TopicVisualLevel = TopicVisualLevel;
exports.createKey = createKey;
exports.defaultTheme = defaultTheme;
exports.getAllSubTopicKeys = getAllSubTopicKeys;
exports.getKeyPath = getKeyPath;
exports.getRelationship = getRelationship;
exports.isThemeType = isThemeType;
//# sourceMappingURL=main.js.map
